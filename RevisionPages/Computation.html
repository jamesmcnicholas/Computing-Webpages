<!DOCTYPE html>
<html lang="en">

<head>
  <link type="text/css" href="../css/style.css" rel="stylesheet" />
  <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
  <title>Computation</title>
</head>

<body class="Computation">
  <div class="navigation">
    <a href="index.html" class="button">Home</a>
    <a href="Processing.html" class="button">Processing</a>
    <a href="Systems.html" class="button">Systems</a>
    <a href="Programming.html" class="button">Programming</a>
    <a href="Development.html" class="button">Development</a>
    <a href="Data.html" class="button">Data</a>
    <a href="Computation.html" class="button">Computation</a>
    <a href="Connectivity.html" class="button">Connectivity</a>
  </div>
  <div class="container" id="home">
    <div class="row text-center">
      <div class="col-md-12">
        <h1 class="head-main"> <i class="fa fa-desktop fa-2x"></i>COMPUTATION</h1>
        <h2 class="head-sub-main">A Level Computer Science</h2>
      </div>
    </div>
  </div>
  </div>
  <section class="color-white " id="about">
    <div class="container">
      <div class="row text-center">
        <div class="col-md-8 col-md-offset-2 ">
          <h2 style="padding-top:50px;">Trees and Graphs</h2>
          <p>
            <h3>Trees and graphs are methods of portraying data structures - They consist of <b>nodes</b>, joined by <b>edges</b></h3>
          </p>
          <div id="container">
            <div id="first">
              <ul style="padding-left: 5%;padding-right: 5%">
                <h4 style="background-color:#6bb6e8">Key features of trees</h4>
                <li>Contain one root node, all other nodes have a <b>parent</b></li>
                <li>Unless the tree is explicitly binary, each node can have any number of <b>child nodes</b></li>
                <li>Nodes with no children are referred to as <b>leaf nodes</b></li>
                <li><b>Circuits</b> are not allowed, as edges have a single direction</li>
                <img src="../img/Tree.png"style="width:70%">
                <p>
              </ul>

            </div>
            <div id="second">
              <ul style="padding-left: 5%;padding-right: 5%">
                <h4 style="background-color:#6bb6e8">Key features of graphs</h4>
                <li>Contain no root node or unique  start points</li>
                <li>Edges can have one, two or no direction at all</li>
                <li>Each node must have at least one connection</li>
                <li><b>Circuits</b> are allowed, as multiple paths can exist to one node</li>
                <img src="../img/graph.png" style="width:70%">
                <p>
              </ul>
          </div>
        </div>
          <p class="spacing-small">
            Graphs can be divided into two categories - Directed and undirected.
            Directed graphs have direction (in the form of arrows) showing the
            path to take. Undirected graphs do not have this propterty, meaning
            there is no outlined path. Trees can be referred to as <b>minimally
            connected directed graphs</b> with only one path from the root node
            to any other node. This works because trees come under the over-arching
            title of graphs.
          </p>
        </div>
        <hr width="75%">
        <h3>Tree Traversal</h3>
        <div id=first>
          <img src="../img/PostOrder.png" style="width:50%">
          <img src="../img/InOrder.png" style="width:50%">
        </div>
      <div id=second>
          <img src="../img/LevelOrder.png" style="width:50%">
          <img src="../img/PreOrder.png" style="width:50%">
      </div>
      </div>
      <p><br>.</p>

    </div>
  </section>
  <section class=" color-light">
    <div class="container">
      <div class="row text-center">
        <div class="col-md-12">
          <h2>Advanced Sorts</h2>
          <h3>Basic pseudocode for bubble and insertion sorts can be seen below</h3>
            <div class="codebox">
              <img src=../img/bubble.png>
            </div>
            <div class="codebox">
              <img src=../img/insertion.png height="200">
            </div>
            <p>
            <div id=first>
              <ul style="padding-left: 5%;padding-right: 5%">
                <h4 style="background-color:#6bb6e8">Mergesort Process</h4>
                <li>1. Create stacks to store pairs of numbers that will represent left and right value</li>
                <li>2. Add the the start and end index of the array to the stacks</li>
                <li>3. Pop the next pair off the stacks, store these in variables called 'left' and 'right' </li>
                <li>4. Create a variable called 'wall' and make it equal to left </li>
                <li>5. Take note of the value of the list at the right most index, call this 'pivot' </li>
                <li>6. Progress from left to one before right, if the value found is less than pivot then... </li>
                <li>7. ...swap it with the value at the wall and move the wall along one </li>
                <li>8. When you reach the end, swap the rightmost element with the wall </li>
                <li>9. If wall - 1 is greater than left, add left and wall - 1 as to the stacks </li>
                <li>10. If wall + 1 is less than right, add wall + 1 and right to the stacks </li>
                <li>11. If the stack is not empty, return to stage 3 </li>
                <li>12. If stack is empty, the list has been successfully sorted </li>
                <p>
              </ul>
              <div class="codebox">
                <img src=../img/merge.png>
              </div>
              <br>
              Merge sorts are very effective at tackling large data sets. Their ability to break down the data into chunks
              and sort those greatly reduces the number of iterations needed. However,
              the sort is more intensive than others, and is not as effective as say, a bubble
              sort on much smaller data sets due to this.
            </div>
            <div id=second>
              <ul style="padding-left: 5%;padding-right: 5%">
                <h4 style="background-color:#6bb6e8">Iterative Quicksort</h4>
                <li>1. Arrange the list you wish to sort into sublists of length one </li>
                <li>2. Prepare a queue and add each of the sublists to the queue </li>
                <li>3. Take two sublists from the end of the queue and prepare a new empty sublist</li>
                <li>4. Look at the first item from each sublist, add the smallest to the new sublist </li>
                <li>5. Repeat stage 3 until one of the two sublists is empty </li>
                <li>6. Add all of the other non-empty sublist to the end of the new sublist </li>
                <li>7. Add the new sublist to the start of the queue </li>
                <li>8. If the queue has more than one item left, return to stage 2</li>
                <li>9. If the queue only has one item list, you are done - that sublist is the sorted list </li>
                  <p>
                <div class="codebox">
                  <img src="../img/quick.png">
                </div>
              </ul>
              <p>
              The quicksort is efficient at sorting items, but is also easy to implement
              It is widely used sort for lists of any size, however can become
              slower when sorting large lists if the chosen pivot is unsuccessful.
          </div>
      </div>

    </div>
  </div>
  </section>
  <section class="color-white " id="work-sec">
    <div class="container">

      <div class="row text-center">
        <div class="col-md-8 col-md-offset-2 ">
          <h2>Pathfinding</h2>

          <h3>DIJKSTRA'S ALGORITHM</h3>
          <p class="spacing-small">
          Dijkstra's algorithm is a way of finding the shortest route through a
          set of connected nodes on a graph. It works by checking every node
          until the one with the lowest value is found, then adding that to the
          list and repeating. The full procedure can be seen below.
          <br><br> Once a value is confirmed to be the
          shortest route to that node, it is 'boxed', marking it as complete.
          This algorithm is good at finding the fastest path, however can take
          a long time, and will only consider faster options when one option becomes
          too long. For example, traveling london to the Isle of White would
          consider routes northbound until it became faster to go south, despite
          it being in the opposite direction.
          <p>
            <ul>
              <h4 style="background-color:#6bb6e8">Dijkstra's Algorithm</h4>
              <li>Label the starting vertex as zero value and box it</li>
              <li>Box the smallest number of those connected to this node</li>
              <li>From this node, consider the distance to every other node</li>
              <li>If the distance is less than the value already at the vertex, cross it out and replace it with the new distance</li>
              <li>If there is no value at this vertex, write down the value</li>
              <li>Repeat from step 2 until the destination is reached</li>
            </ul>
            <img src="../img/dijkstra.gif">
            <p>
          Pseudocode for this algorithm is as follows:
          <div class=codebox>
            <img src="../img/dijkstraPseudo.png">
        </div>
          <h3>THE A* ALGORITHM</h3>
          <p class=spacing-small>
          The A* algorithm uses a heuristic (best guess) approach to find the shortest route ot a destination. Instead of checking
          every possible route, it measures each node around a node and checks the distance to it. The distance is determined by its position.
          Adjacent nodes are given a value of 10, and diagonals a value of 14 (this is due to pythagoras, but numbers are multiplied by 10 and rounded).
          Each node has three values, a <b>G cost - the distance from the starting node</b>, an <b>H cost - distance from the end node</b>, and an <b>F cost - G cost + H cost</b>.
          Each iteration, the node with the smallest F-cost is 'explored'. After a node has been explored, each connected node is given an F cost and the process repeats until the end is reached.
          <p>
          <img src=../img/AStar.gif width="30%">
          <p>
          Pseudocode for this algorithm is as follows
          <div class=codebox>
            <img src=../img/AStarPseudo.png>
          </div>
      </div>
  </section>
  <section class=" color-light">
    <div class="container">

      <div class="row text-center">
        <div class="col-md-12">
          <h2>Algorithms and Efficiency</h2>
          <p>
            <h3>The data protection act was established in 1998. The eight principles are as follows:</h3>
            <ul class="row text-left">
              <li>Personal data should be obtained and processed fairly amnd lawfully </li>
              <li>Personal data can be held only for specified and lawful purposes </li>
              <li>Personal data should be adequate, relevant and not excessive for the required purpose </li>
              <li>Personal data should be accurate and kept up-to-date </li>
              <li>Personal data should not be kept for longer than is necessary </li>
              <li>Data must be processed in accordance with the rights of the data subject </li>
              <li>Appropriate security measures must be taken against unauthorised access </li>
              <li>Personal data cannot be transferred to countries outside the E. U. unless the country has similar legislation to the D.P.A. </li>
            </ul>
            The data protection act is designed to do as it states, ensure the safety of personal data. Each principle aims to keep secure data deemed personal.<br> This includes racial or ethnic origin, political opinions and religious beliefs, among
            the obvious such as name and address. In some cases, collection<br> of such material may be required, for example, a Catholic school who only employs Catholics, might wish to know the religious beliefs of new teachers, while<br> The police
            force will need to know if new recruits have any previous criminal convictions.
          </p>
        </div>

      </div>
    </div>
  </section>
  </div>
  <h4 align="right">James McNicholas 2017-2018</h4>
</body>

</html>
